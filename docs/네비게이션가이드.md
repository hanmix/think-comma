# 네비게이션 정책 가이드

본 문서는 웹에서 SwiftUI `NavigationStack`을 모방한 스택 네비게이션 정책과 구현 규칙을 요약합니다. 대상: Vue 3 + Vue Router 4 + Pinia(Setup Store).

## 목적
- 일관된 라우팅 경험 제공: 뒤로가기/제스처/헤더 버튼/로고 클릭의 의미를 통일
- 앱스러운 스택 모델 제공: pop, popToRoot, replace 정책을 명확히
- 점진 도입: 기존 Router API와 병행 가능, 필요 화면부터 적용

## 핵심 구성요소
- composable: `src/composables/useNavStack.ts`
  - API: `push`, `replace`, `pop`, `popToRoot`, `resetTo`, `canGoBack`, `depth`
- store: `src/stores/navStack.ts` (Pinia Setup Store)
  - 스택과 브라우저 `history.state.position` 동기화 데이터 보관
- sync 훅: `src/router/navStackSync.ts`
  - `router.afterEach`에서 제스처/브라우저 뒤·앞으로가기를 스택과 동기화
- 공통 타입: `src/types/navigation.ts`
  - `StackId`, `DEFAULT_STACK_ID("main")`
- 라우트 메타
  - `meta.stackId`: 소속 스택 식별자(기본 `main`)
  - `meta.isRoot`: 해당 스택의 루트 라우트 표시(Home 등)

## 사용 규칙(정책)
1) 이동 기본값
- 일반 이동은 `push`를 기본으로 합니다.
- “현재 화면을 대체” 의도일 때만 `replace`를 사용합니다(예: 임시 라우트, 완료 화면).

2) 뒤로가기 의미
- 인앱 뒤로가기 버튼은 `pop()`을 호출합니다.
- 스택 깊이(`depth`)가 1 이하일 경우 버튼을 숨깁니다(`canGoBack`).

3) 홈/루트 이동
- 로고(또는 홈 액션)는 스택을 루트까지 `popToRoot()`하는 것을 권장합니다(앱스러운 동작).
- 웹 관성을 유지하려면 로고를 `router.push({ name: 'home' })`로 바꿔 적용할 수 있습니다.

4) 특수 플로우
- 온보딩/콜백/스플래시 등 “돌아가면 혼란”인 화면은 홈 이동 시 `replace` 또는 `popToRoot`를 사용해 스택을 정리합니다.
- 필요 시 라우트에 `meta: { discardOnHome: true }` 같은 정책 메타를 정의해 조건부 처리합니다.

5) 브라우저 제스처
- 사용자가 브라우저 뒤/앞으로가기를 사용할 때도 스택이 자동 동기화됩니다(`navStackSync`).
- `pop()`/`popToRoot()`는 내부적으로 `router.go(...)`를 사용해 브라우저 히스토리와 일치시킵니다.

## 라우트 메타 규칙
```ts
// src/router/index.ts 예시
{
  path: '/',
  name: 'home',
  component: HomePage,
  meta: { stackId: 'main', isRoot: true },
},
{
  path: '/flow',
  name: 'flow',
  component: () => import('@/views/ThinkingFlow.vue'),
  meta: { stackId: 'main' },
}
```

## API 사용 예시
```ts
// 컴포넌트 setup
import { useNavStack } from '@/composables/useNavStack'

const { push, replace, pop, popToRoot, canGoBack, depth } = useNavStack()

// 이동
await push({ name: 'flow' })
await replace({ name: 'example' })

// 뒤로가기
if (canGoBack.value) await pop()

// 루트로
await popToRoot() // 홈(루트)까지 pop
```

## 네비게이션 바 가이드
- 뒤로가기 버튼: `canGoBack`이 true일 때만 노출, 클릭 시 `pop()`.
- 로고 클릭: 기본은 `popToRoot()` 권장. 웹 관성 유지 시 `router.push({ name: 'home' })`.

## 멀티 스택(탭) 운용
- 탭별로 `meta.stackId`를 분리하여 각 탭이 독립 스택을 가지게 합니다(예: `main`, `settings`, `profile`).
- 탭 재탭 시 `popToRoot()`를 적용하면 iOS 탭 UX와 유사한 경험을 제공합니다.

## 딥링크/리다이렉트 처리
- 딥링크 진입 시 `navStackSync`가 현재 라우트를 기준으로 스택을 시드합니다.
- 인증 후 리다이렉트 등은 `replace`로 정착시키되, 이후 플로우는 `push`를 사용합니다.

## 마이그레이션 전략
1. 라우트에 `meta.stackId`와 `meta.isRoot`를 설정합니다.
2. 네비게이션 바, 플로우 핵심 페이지부터 `useNavStack` API로 치환합니다.
3. 뒤로가기/로고 행동을 정책에 맞게 변경합니다.
4. QA 중 제스처/브라우저 뒤로가기를 함께 검증합니다.

## 체크리스트
- [ ] 홈 라우트에 `meta.isRoot`가 설정되었는가?
- [ ] 뒤로가기 버튼은 `canGoBack` 기준으로 노출되는가?
- [ ] 로고 클릭 정책(앱스럽게 popToRoot vs 웹 관성 push)이 결정되었는가?
- [ ] 특수 플로우에서 `replace`/`popToRoot` 정책이 반영되었는가?
- [ ] 브라우저 제스처로도 스택이 정상 동기화되는가?

## 자주 묻는 질문(FAQ)
Q. 브라우저 뒤로가기만으로 이동하면 스택이 틀어지지 않나요?
- A. `navStackSync`가 `history.state.position`을 이용해 afterEach에서 스택을 동기화합니다.

Q. 왜 `pop()`이 `router.replace`가 아니라 `router.go(-1)`인가요?
- A. 브라우저 히스토리와의 일관성을 위해 실제 히스토리를 이동합니다. 가상 스택만 조작하면 제스처와 어긋납니다.

Q. 웹과 앱 중 어떤 정책이 기본인가요?
- A. 기본은 웹 관성 유지(홈에서 뒤로가기 숨김). 앱스러운 경험이 필요할 경우 로고에 `popToRoot()`를 적용하세요.

